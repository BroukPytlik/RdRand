
/* gcc -DHAVE_X86INTRIN_H -Wall -Wextra -fopenmp -mrdrnd -I./ -O3 -o gen rdrand-gen.c rdrand.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <getopt.h>
#include <omp.h>
#include <string.h>
#include <errno.h>
#include <inttypes.h>
#include "../src/rdrand.h"
//#include <rdrand-0.1/rdrand.h>
#include "../src/rdrand-gen.h"


#define SIZEOF(a) ( sizeof (a) / sizeof (a[0]) )

static const char* HELP_TEXT =
	"Usage: %s [OPTIONS]\n"
	"If no output file is specified, the program will print random values to STDOUT.\n\n"
	"OPTIONS\n"
	"  --help       -h      Print this help.\n"
	"  --amount     -n NUM  Generate given amount of bytes. Suffixes: k, M, G, T.\n"
	"                       Without the option or when 0, generate unlimited amount.\n"
	"  --method     -m NAME Use method NAME (default is %s).\n"
	"  --output     -o FILE Save the generated data to the file.\n"
	"  --threads    -t NUM  Run the generator in NUM threads (default %u).\n"
	"\n";

/**
 * Parse arguments and save flags/values to cnf_t* config.
 */
void parse_args(int argc, char** argv, cnf_t* config)
{
	int i;
	char optC;
	static struct option long_options[] =
	{
		{"help", no_argument,       0, 'h'},
		{"amount",    required_argument, 0, 'n'},
		{"method",  required_argument, 0, 'm'},
		{"output",  required_argument, 0, 'o'},
		{"threads",  required_argument, 0, 't'},
		{0, 0, 0, 0}
	};

	opterr = 0;
	while (1)
	{

		/* getopt_long stores the option index here. */
		int option_index = 0;

		optC = getopt_long (argc, argv, "hn:m:o:t:",
				    long_options, &option_index);

		/* Detect the end of the options. */
		if (optC == -1)
			break;

		switch (optC)
		{

		case 'h':
			config->help_flag = 1;
			break;

		case 'n':
			config->bytes = strtoumax(optarg, NULL,10);
			break;

		case 't':
			config->threads = strtoumax(optarg, NULL, 10);

			break;

		case 'o':
			config->output_filename = optarg;
			break;

		case 'm': // method
			for(i = 0; i<METHODS_COUNT; i++)
			{
				if(strcmp(optarg,METHOD_NAMES[i]) == 0)
				{
					config->method = i;
					break;
				}
			}
			if(i == METHODS_COUNT)
			{
				fprintf (stderr,"Error: Unknown method to use!\n");
				exit(EXIT_FAILURE);
			}
			break;

		case '?':
			/* getopt_long already printed an error message. */
			break;

		default:
			abort ();
		}
	}

	/** Compute the size of a chunk:
	 *  Total bytes / 8 = number of 64bit blocks.
	 *  No. 64bit blocks / threads = size of chunk
	 */
	if(config->bytes > 0)
	{
		config->blocks = config->bytes / 8;
		config->chunk_size = config->blocks / config->threads;

		if(config->chunk_size > 0)
        {
            if(config->chunk_size > MAX_CHUNK_SIZE)
			config->chunk_size = MAX_CHUNK_SIZE;

		config->chunk_count = config->blocks % config->chunk_size;
		config->ending_bytes = config->bytes % config->chunk_size*config->threads;
        }
        else
        {
		config->ending_bytes = config->bytes ;
        }


		printf("Will generate %u of 64bit blocks using %u chunks of size %u blocks, ending: %u bytes.\n", (uint)config->blocks, (uint)config->chunk_count, (uint)config->chunk_size, (uint)config->ending_bytes);
	}



}

/**
 * Fill chunks with random data
 * Return number of generated bytes
 */
size_t generate_chunk(cnf_t *config)
{
	unsigned int i, n;
	size_t written, written_total;
	uint64_t buf[config->chunk_size*config->threads];
	written_total = 0;
	for(n = 0; n < config->chunk_count; n++)
	{

		written = 0;
		/** At first fill chunks in all parallel threads */
#pragma omp parallel for reduction(+:written)
		for ( i=0; i<config->threads; ++i)
		{
			switch(config->method)
			{
			case GET_BYTES:
				written += rdrand_get_bytes_retry((uint8_t*)&buf[i*config->chunk_size], config->chunk_size*8,1)/8;
				break;
			case GET_UINT8_ARRAY:
				written += rdrand_get_uint8_array_retry((uint8_t*)&buf[i*config->chunk_size], config->chunk_size*8, 1)/8;
				break;
			case GET_UINT16_ARRAY:
				written += rdrand_get_uint16_array_retry((uint16_t*)&buf[i*config->chunk_size], config->chunk_size*4, 1)/4;
				break;
			case GET_UINT32_ARRAY:
				written += rdrand_get_uint32_array_retry((uint32_t*)&buf[i*config->chunk_size], config->chunk_size*2, 1)/2;
				break;
			case GET_UINT64_ARRAY:
				written += rdrand_get_uint64_array_retry(&buf[i*config->chunk_size], config->chunk_size, 1);
				break;

			case GET_RESEED64_DELAY:
				written += rdrand_get_uint64_array_reseed_delay(&buf[i*config->chunk_size], config->chunk_size, 1);
				break;
			case GET_RESEED64_SKIP:
				written += rdrand_get_uint64_array_reseed_skip(&buf[i*config->chunk_size], config->chunk_size, 1);
				break;
			}
		}
		/* test generated amount */
		if ( written != SIZEOF(buf) )
		{
			fprintf(stderr, "Warning: bytes generated %zu, bytes expected %zu, trying to regenerate it\n", written, SIZEOF(buf));
			break;
		}


		// TODO recovery from missing bytes

		written = fwrite(buf, sizeof(buf[0]), SIZEOF(buf), config->output);
		if ( written !=  SIZEOF(buf) )
		{
			perror("fwrite");
			fprintf(stderr, "ERROR: fwrite - bytes written %zu, bytes to write %zu\n", sizeof(buf[0]) * written, sizeof(buf));
			break;
		}
		written_total += written;


	}
	return written_total*8;
}


/**
 * Fill the ending bytes with random data
 * Return number of generated bytes
 */
size_t generate_ending(cnf_t *config)
{
	size_t written_total;
	uint8_t buf[config->ending_bytes];

    written_total = rdrand_get_bytes_retry(&buf[0], config->ending_bytes,1);
    /* test generated amount */
    if ( written_total != SIZEOF(buf) )
    {
        fprintf(stderr, "ERROR: bytes generated %zu, bytes expected %zu\n", written_total, SIZEOF(buf));
        return written_total;
    }
    written_total = fwrite(buf, sizeof(buf[0]), SIZEOF(buf), config->output);
    if ( written_total !=  SIZEOF(buf) )
    {
        perror("fwrite");
        fprintf(stderr, "ERROR: fwrite - bytes written %zu, bytes to write %zu\n", sizeof(buf[0]) * written_total, sizeof(buf));
        return written_total;

    }
	return written_total;
}

/**
 * Generate requested amount of bytes
 * Return amount of bytes truly generated.
 */
size_t generate(cnf_t *config)
{
	size_t written;
	written = 0;
	/** At first fill chunks in all parallel threads.
	 *  If no size is specified, then the program
	 *  will never get over this.
	 */
	written = generate_chunk(config);

    /** Then fill the few ending bytes in one thread. */
    written += generate_ending(config);
	return written;
}

/*****************************************************************************/

int main(int argc, char** argv)
{
	int i;
	cnf_t config = {NULL, stdout, DEFAULT_METHOD, 0, DEFAULT_THREADS, DEFAULT_BYTES,0,0,0,0};
	parse_args(argc, argv,&config);
	if(config.help_flag)
	{
		printf(HELP_TEXT,argv[0],METHOD_NAMES[DEFAULT_METHOD],DEFAULT_THREADS);
		fprintf(stdout,"\nAccessible methods:\n");
		for(i = 0; i<METHODS_COUNT; i++)
		{
			if(i == DEFAULT_METHOD)
			{
				fprintf(stdout,"  %s [default]\n",METHOD_NAMES[i]);
			}
			else
			{
				fprintf(stdout,"  %s\n",METHOD_NAMES[i]);
			}
		}
		exit(EXIT_SUCCESS);
	}

	if(config.output_filename != NULL)
	{
		config.output = fopen(config.output_filename, "wb");
		if( config.output == NULL )
		{
			fprintf(stderr,"ERROR: Can't open file %s!\n", config.output_filename);
			exit(EXIT_FAILURE);
		}
	}

    generate(&config);

	fclose(config.output);

	exit(EXIT_SUCCESS);
}
