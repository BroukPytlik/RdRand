.\" Manpage for librdrand-aes.
.\" Contact jan@tulak.me to correct errors or typos.
.TH man 3 "24 April 2014" "1.2" "librdrand-aes man page"
.SH NAME
librdrand-aes \- Library for generating random values by using RdRand on Intel's CPUs. This AES extensions enable to encrypt the output of RdRand by AES-CTR from OpenSSL library. This efectively mitigate any possible weakness and predictability that could be in the RdRand circruits.


.SH SYNOPSIS
.B #include <librdrand-aes.h>

Before use, the encryption has to be initialized by one (and only one) of these functions:

.BI "int rdrand_set_aes_keys(unsigned int " amount ", size_t " key_length ", unsigned char **" keys ", unsigned char **" nonces ");"

.B int rdrand_set_aes_random_key();

At the end of usage, clean the encryption keys with:

.B void rdrand_clean_aes();

For getting encrypted data use:

.BI "unsigned int rdrand_get_bytes_aes_ctr(void *" dest ",  const unsigned int " count ", int " retry_limit ");"

If you want to encrypt the data multiple times, or if you want to encrypt also something else, using the same encryption engine and keys/nonces, you can use this function:

.BI "int rdrand_enc_buffer(void* " dest ", void* " src ", size_t " len ");"

.SH DESCRIPTION
This AES extension of librdrand implements OpenSSL AES-CTR encryption to provide possiblity of RdRand encryption. Performance impact is roughly about 10% decrease, but in return it effectively mitigate any security flaw, that could possibly be in the RdRand.

In order to use this extensions, it is necessary to initialize encryption engine at first. There are two functions for this. One of them,
.BR rdrand_set_aes_random_key ,
do not need any argument and when used, encryption keys and nonces are generated by an OpenSSL random number generator. The other one,
.BR rdrand_set_aes_keys ,
takes a set of keys and nonces. The keys has to be all the same length and double of length of nonces (i.e. if nonce is 64bit, key has to be 128bit). 

Length of the keys is in bytes (so for 128bit key there will be 16). 
The function copy the keys and nonces, so you can immediately destroy your variables containing the keys.
The minimum and maximum key lengths are in 
.I RDRAND_MAX_KEY_LENGTH
and
.I RDRAND_MIN_KEY_LENGTH
constants. Default length, which is used in case of random key, is 
.I RDRAND_DEFAULT_KEY_LEN
which is 16 (for 128bit).

When the random key is used, new key is generated after a random amount of encrypted bytes. When keys are given manualy, they are cycling in given order and after a fixed amount of generated bytes (
.IR RDRAND_MAX_COUNTER 
- 4 KiB). Thus, when keys are manually entered, OpenSSL is NOT used for anything except the encryption itself.

.B rdrand_get_bytes_aes_ctr
function works as 
.B rdrand_get_bytes 
from the main library. It fills 
.I dest 
with 
.I count
bytes of random encrypted data.
.I retry_limit 
specify maximum amount of tries in case the RdRand instruction fails.
This function is internally using 
.B rdrand_enc_buffer
for the encryption, which is also provided, so you can use it to encrypt some data with it too (for example for multiple encryption).

It is imporant to remove keys from memory once finished, by calling
.BR rdrand_clean_aes .

Note that this extension is not thread-safe: If multiple threads attempt to encrypt at the same time, it can cause incorrect state of the encryption engine or even a crash of your application.


.SH SEE ALSO
rdrand-gen(7)
librdrand(3)

.SH BUGS
No known bugs.

.SH AUTHOR
Jan Tulak (jan@tulak.me)
Jiri Hladky (hladky.jiri@gmail.com)
